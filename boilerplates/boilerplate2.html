<!DOCTYPE HTML> 
<html> 
	<head> 
		<meta charset="utf-8"> 
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>WebGL Boilerplate</title> 
		
		<style> 
			html, body 
            {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				width: 100%;
				height: 100%;
			}
			canvas 
            {
				width: 100%;
				height: 100%;
			}
		</style> 
	</head> 
	<body> 
 
		<canvas></canvas>
		<div id="info"></div> 
 
		<script id="vs" type="x-shader/vertex"> 
 
            attribute vec3 vertPosition;
            attribute vec3 vertColour;
            varying vec3 fragColour;
 
            void main() 
            {
                fragColour = vertColour;
				gl_Position = vec4(vertPosition, 1.0);
			}
 
        </script> 
        
        <script id="fs" type="x-shader/fragment">   
                      
			varying vec3 fragColour;
			
            void main(void)
            {
                gl_FragColor = vec4(fragColour, 1.0);
            }
 
		</script> 
 
		<script> 

			var canvas, 
			    gl, 
			    vertexShader, fragmentShader, 
			    currentProgram,
			    parameters = {  start_time  : new Date().getTime(), 
			                    time        : 0, 
			                    screenWidth : 0, 
			                    screenHeight: 0 };
				geometries = [];
			main();
 
            function main() 
            {
				vertexShader = document.getElementById('vs').textContent;
				fragmentShader = document.getElementById('fs').textContent;
 
				canvas = document.querySelector('canvas');
 
				// Initialise WebGL
                try 
                {
					gl = canvas.getContext('experimental-webgl');
                } 
                catch (error) { }
 
                if (!gl) 
                {
					throw "Cannot create webgl context!";
                }

				// Create Program
				currentProgram = createProgram(vertexShader, fragmentShader);

				var vertices = 
                [
                    0.0, 0.5,
                    -0.5, -0.5,
                    0.5, -0.5,
                ];

				var colours = 
                [
                    1.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 1.0
                ];

				var geometry =
				{
					vertexBuffer: null,
					colourBuffer: null,
					elementCount: 0
				};

				initializeVAO(geometry);
				loadGeometry(geometry, vertices, colours, 3);
				geometries.push(geometry);

				render(geometries);
			}

			function initializeVAO(geometry)
			{
				geometry.vertexBuffer = gl.createBuffer();
				geometry.colourBuffer = gl.createBuffer();

				var vertexPosition = gl.getAttribLocation(currentProgram, 'vertPosition');
				var vertexColour = gl.getAttribLocation(currentProgram, 'vertColour');
				gl.bindBuffer(gl.ARRAY_BUFFER, geometry.vertexBuffer);
                gl.vertexAttribPointer
				(
					vertexPosition, 
					2, 
					gl.FLOAT, 
					false, 
					2 * Float32Array.BYTES_PER_ELEMENT, 
					0
				);
				gl.enableVertexAttribArray(vertexPosition);

                gl.bindBuffer(gl.ARRAY_BUFFER, geometry.colourBuffer);
				gl.vertexAttribPointer
				(
					vertexColour, 
					3, 
					gl.FLOAT, 
					false, 
					3 * Float32Array.BYTES_PER_ELEMENT, 
					0
				);
				gl.enableVertexAttribArray(vertexColour);

				gl.bindBuffer(gl.ARRAY_BUFFER, null);
			}
 
			function loadGeometry(geometry, vertices, colours, elementCount)
			{
				geometry.elementCount = elementCount;

				gl.bindBuffer(gl.ARRAY_BUFFER, geometry.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, geometry.colourBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colours), gl.STATIC_DRAW);

				gl.bindBuffer(gl.ARRAY_BUFFER, null);
			}

            function createProgram(vertex, fragment) 
            {
				var program = gl.createProgram();
 
				var vs = createShader(vertex, gl.VERTEX_SHADER);
				var fs = createShader('#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment, gl.FRAGMENT_SHADER);
 
                if (vs == null || fs == null) 
                    return null;
 
				gl.attachShader(program, vs);
				gl.attachShader(program, fs);
 
				gl.deleteShader(vs);
				gl.deleteShader(fs);
 
				gl.linkProgram(program);
 
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) 
                {
					alert("ERROR:\n" +
					"Status: " + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + "\n" +
					"Error: " + gl.getError() + "\n\n" +
					"Vertex Shader\n" + vertex + "\n\n" +
					"Fragment Shader\n" + fragment);
 
					return null;
				}
				return program;
			}
 
            function createShader(src, type) 
            {
				var shader = gl.createShader(type);
 
				gl.shaderSource(shader, src);
				gl.compileShader(shader);
 
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
 
					alert((type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT" ) + " SHADER:\n" + gl.getShaderInfoLog(shader));
					return null;
				}
				return shader;
			}
 
            function resizeCanvas(event) 
            {
				if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight) 
                {
					canvas.width = canvas.clientWidth;
					canvas.height = canvas.clientHeight;
					parameters.screenWidth = canvas.width;
					parameters.screenHeight = canvas.height;
					gl.viewport(0, 0, canvas.width, canvas.height);
				}
			}
 
            function render(geometries) 
            {
                if (!currentProgram) 
                    return;

				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
 
				// Load program into GPU
				gl.useProgram(currentProgram);

				// Render geometry
				geometries.forEach(g => 
				{
					gl.bindBuffer(gl.ARRAY_BUFFER, g.vertexBuffer);
					gl.drawArrays(gl.TRIANGLES, 0, g.elementCount);
				});
				
				gl.bindBuffer(gl.ARRAY_BUFFER, null);	
            }
            
		</script> 
	</body> 
</html>